#!/usr/bin/python3

from task import Cipher, P224, long_to_bytes, bytes_to_long, read_file, write_file

from zlib import crc32
from struct import pack

from gmpy2 import invert
from fastecdsa.point import Point


# https://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python

def legendre_symbol(a, p):
    """ Compute the Legendre symbol a|p using
        Euler's criterion. p is a prime, a is
        relatively prime to p (if p divides
        a, then a|p = 0)

        Returns 1 if a has a square root modulo
        p, -1 otherwise.
    """
    ls = pow(a, (p - 1) // 2, p)
    return -1 if ls == p - 1 else ls


def modular_sqrt(a, p):
    """ Find a quadratic residue (mod p) of 'a'. p
        must be an odd prime.

        Solve the congruence of the form:
            x^2 = a (mod p)
        And returns x. Note that p - x is also a root.

        0 is returned is no square root exists for
        these a and p.

        The Tonelli-Shanks algorithm is used (except
        for some simple cases in which the solution
        is known from an identity). This algorithm
        runs in polynomial time (unless the
        generalized Riemann hypothesis is false).
    """
    # Simple cases
    #
    if legendre_symbol(a, p) != 1:
        return 0
    elif a == 0:
        return 0
    elif p == 2:
        return 0
    elif p % 4 == 3:
        return pow(a, (p + 1) // 4, p)

    # Partition p-1 to s * 2^e for an odd s (i.e.
    # reduce all the powers of 2 from p-1)
    #
    s = p - 1
    e = 0
    while s % 2 == 0:
        s //= 2
        e += 1

    # Find some 'n' with a legendre symbol n|p = -1.
    # Shouldn't take long.
    #
    n = 2
    while legendre_symbol(n, p) != -1:
        n += 1

    # Here be dragons!
    # Read the paper "Square roots from 1; 24, 51,
    # 10 to Dan Shanks" by Ezra Brown for more
    # information
    #

    # x is a guess of the square root that gets better
    # with each iteration.
    # b is the "fudge factor" - by how much we're off
    # with the guess. The invariant x^2 = ab (mod p)
    # is maintained throughout the loop.
    # g is used for successive powers of n to update
    # both a and b
    # r is the exponent - decreases with each update
    #
    x = pow(a, (s + 1) // 2, p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e

    while True:
        t = b
        m = 0
        for m in range(r):
            if t == 1:
                break
            t = pow(t, 2, p)

        if m == 0:
            return x

        gs = pow(g, 2 ** (r - m - 1), p)
        g = (gs * gs) % p
        x = (x * gs) % p
        b = (b * g) % p
        r = m


def xor(block1, block2):
    return bytes(x^y for x, y in zip(block1, block2))


def build_png(width, height, bit_depth, color_type, compression_method, filter_method, interlace_method):
    header = b'\x89PNG\r\n\x1a\n\x00\x00\x00\x0d'
    ihdr = b'IHDR' + pack('>IIBBBBB', 
        width, 
        height, 
        bit_depth, 
        color_type, 
        compression_method, 
        filter_method, 
        interlace_method
    )
    return header + ihdr + pack('>I', crc32(ihdr))


def brute_png(min_size=1, max_size=(1<<32)-1):
    color_type_and_bit_depths = [
        (0, (1, 2, 4, 8, 16)),
        (2, (8, 16)),
        (3, (1, 2, 4, 8)),
        (4, (8, 16)),
        (6, (8, 16))
    ]
    compression_method = 0
    filter_method = 0
    interlace_methods = [0, 7]
    for size in range(min_size, max_size):
        print(size)
        for color_type, bit_depths in color_type_and_bit_depths:
            for bit_depth in bit_depths:
                build = lambda interlace_method: build_png(
                    size,
                    size,
                    bit_depth, 
                    color_type, 
                    compression_method, 
                    filter_method,
                    interlace_method
                )
                yield list(map(build, interlace_methods))


def recover_seed(png_enc, curve, block_size, backdoor):
    inverse = int(invert(backdoor, curve.q))
    for png_plains in brute_png():
        png_start = png_plains[0][:block_size]
        x = bytes_to_long(xor(png_start, png_enc))
        y_quad = curve.evaluate(x)
        y = modular_sqrt(y_quad, curve.p)
        if not y:
            continue
        if curve.is_point_on_curve((x, y)):
            point = Point(x, y, curve)
            seed = (inverse * point).x
            key = (backdoor * curve.G * seed).x
            png_next = xor(png_enc[block_size:], long_to_bytes(key))
            for png_plain in png_plains:
                if png_next.startswith(png_plain[block_size:]):
                    return png_plain[:block_size] + png_next, long_to_bytes(seed)


def main():
    flag_enc = read_file('flag.png.enc')
    curve, block_size, backdoor = P224, 28, 31337
    flag_start, seed = recover_seed(flag_enc[:block_size*2], curve, block_size, backdoor)
    cipher = Cipher(seed, curve)
    flag_next = cipher.crypt(flag_enc[block_size*2:])
    write_file('flag.dec.png', flag_start + flag_next)


if __name__ == '__main__':
    main()
