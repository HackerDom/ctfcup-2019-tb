# Reverse | Arbacoin secret market

## Информация

> В ходе секретной спецоперации была найдена засекреченная разработка Arbalest of Siberia.
> 
> Она представляет собой магазин, продающих различные запрещённые товары и услуги.
> 
> Для разработки использовался один из самых отвратительных языков программирования.
> 
> Легендарным подвигом нам удалось добыть образ сервера. Но никто не хочет исследовать этот кусок ... кода.
> 
> Если у тебя получится обойти авторизацию, сопротивление щедро отблагодарит тебя.
> 
> `http://<ip>:<port>`


## Запуск

Отдать командам бинарник из deploy/static и ip-адрес сервера

```sh
cd deploy
./docker_build.sh
./docker_run.sh
```


## Описание

ELF 64bit, Golang, no strip, no pack

Суть задания - разборать алгоритм проверки куки и сгенерировать подходящую


## Решение

Даже не стрипанный Golang-бинарь исследовать довольно сложно, но есть пара трюков, которые упростят анализ (в данном случае).

1. Т.к. это CTF-таск тут есть довольно простая и понятная идея - получить флаг, не забываем об этом.
2. Судя по тому, что там дают адрес сайта, флаг находится на сайте, значит нужно получить доступ к сайту. А бинарь является как раз таки веб-приложением.
3. Сразу в поиске функций вводи "main_" и получаем все функции для данного модуля (то есть модуля который писал пользователь). Таким образом мы очень сильно сужаем область исследования.
4. Замечаем функцию main_check_cookie - она то нам и нужна.
5. Можно посмотреть функции логина, но в них нет ничего интересно. По сути залогиниться нельзя, авторизация только через куки.
6. Перед вызовом функции проверки куки, можно отследить, что значение берётся из переменной "asm_dev_test", теперь мы знаем имя куки-переменной.
7. Функция проверки в целом не сложная, но анализировать её тяжеловато. Из поверхностного анализа можно вынести, что как минимум 2 раз внутри 2ух разных циклов вызывается расчёт контрольной суммы. 
8. Определить алгоритм контрольной суммы можно по константам.
8.5 На этом моменте пора начать отладку, иначе будет больно.
9. С помощью отладчика можно определить, что размер значения куки должны быть 20 байт (есть проверка в начале функции).
10. Далее идёт самый сложный момент, необходимо с помощью отладки и анализа кода понять, что куки разбивается на 10 частей по 2 байта и от каждой части вычисляется 2-байтная контрольная сумма и помещается в массив.
11. После этого идёт очень похожий код, потому что тоже самое происходит с первыми 10-ю символами куки и в итоге мы имеем два массива с контрольными сумами одинакового размера
12. После чего эти массивы XOR'ятся и сравниваются с эталонными заложенными в память бинарника.
13. XOR и сравнение происходит в конце функции, а эталонные значения лежат по адресу (0x00000000084E1E0 взято из IDA 7.0)
14. Собрав всё воедино, можно понять, что алгоритм вроде как выглядит стойким, но это не так. Реализуем небольшой брут скрипт для подбора куки.

В данном случае эксплоит - это скрипт получения верной куки.

[Пример эксплоита](solve/solver.py)


## Флаг

`Cup{4455f158f0c9c805caefe8bd88488da7f8810f186fedc958a9d0f5dc346395ca}`
