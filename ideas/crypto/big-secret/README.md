# Crypto | Big Secret

## Информация

> Похоже, что Arbalests of Siberia плохо заботятся о безопасности своих каналов связи. 
> 
> Или делают вид, что плохо заботятся.
> 
> Совсем недавно они передавали какую-то очень секретную информацию по одному из своих каналов.
> 
> Или нам только показалось, что передавали?
> 
> Это не имеет значения. В любом случае, ваша задача — достать эту информацию.


## Описание

[Сервер](service/server.py) реализует [протокол Гиллу-Кискатра](https://ru.wikipedia.org/wiki/Протокол_Гиллу_—_Кискатра) и предоставляет возможность удостовериться, что сервер действительно владеет флагом. Какую-то информацию о содержимом самого флага сервер не даёт.


## Решение

Заходим на Википедию и читаем, что Гиллу-Кискатра — это протокол с нулевым разглашением, который не раскрывает ни единого бита секретной информации. Значит, нам нужно поискать ошибки в его реализации.

Посмотрим на генерацию числа `r`:

```py3
def _generate_multiplier(self):
    r = 0
    while not 1 <= r <= self._key.n - 1:
        r = getrandbits(self._bits) ^ \
            getrandbits(self._bits)
    return int(invert(r, self._key.n))
```

Значение `self._bits` равно **1024**, а размер `self._key.n` — **2048** бит. Это значит, что генерируемый `r` имеет длину всего в половину модуля `n`? Нет, потому что функция возвращает не `r`, а `1/r`, который имеет длину равную длине модуля.

Что мы можем сделать? Мы можем возвести число `x` в первую степень, тогда от сервера мы получим `x/r == z (mod n)`. 

Нужно заметить, что оба числа `x` и `r` — "маленькие" по сравнению с модулем `n` и числом `z`. А для нахождения чего-то "маленького" обычно помогает алгоритм [LLL](https://en.wikipedia.org/wiki/Lenstra–Lenstra–Lovász_lattice_basis_reduction_algorithm).

[Пример решения](exploit.sage)


## Флаг

`Cup{p13453_dO_n0T_r011_y0ur_0wN_cryp70}`
