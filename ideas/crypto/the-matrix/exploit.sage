#!/usr/bin/env sage

import re

from socket import socket, AF_INET, SOCK_STREAM


NAME = 'test'
NAME_HASH = int(NAME.encode('hex'), 16)

HACKER = 'neo'
HACKER_HASH = int(HACKER.encode('hex'), 16)


#
# INTERACTION
#


def numbers(data):
    return tuple(map(int, re.findall('\d+', data)))


def wakeup(io, name):
    # wake up
    io.write('1\n')
    io.write(name + '\n')
    io.flush()
    for _ in range(3 + 1):
        io.readline()


def collect_signatures(io, name, count):
    signs = []
    for i in range(count):
        # show your info
        io.write('1\n')
        # change your name
        io.write('2\n')
        io.write(name + '\n')
        io.flush()
    for i in range(count):
        for _ in range(6 + 1):
            io.readline()
        signs.append(numbers(io.readline()))
        for _ in range(6 + 1):
            io.readline()
    return signs


def change_name(io, name, sign):
    # change your name
    io.write('2\n')
    io.write(name + '\n')
    # yes
    io.write('1\n')
    io.write(str(sign).replace('L', '') + '\n')
    io.flush()
    for _ in range(6 + 1 + 3 + 1):
        io.readline()


def collect_oracle(io, count):
    for _ in range(count):
        # ask the oracle
        io.write('3\n')
    io.flush()
    values = []
    for i in range(count):
        for _ in range(6):
            io.readline()
        values.append(numbers(io.readline())[0])
    return values


def get_architect_answers(io, count):
    for _ in range(6):
        io.readline()
    # fight the architect
    io.write('4\n')
    for _ in range(count):
        # answer
        io.write('0\n')
    io.flush()
    answers = []
    for i in range(count):
        for _ in range(3):
            io.readline()
        answers.append(numbers(io.readline())[0])
    return answers


def read_flag(io, answer):
    # answer
    io.write(str(answer) + '\n2\n')
    io.flush()
    for _ in range(3):
        io.readline()
    line = io.readline()
    return line[line.index(':')+1:]


#
# LATTICES
#


def recover_x(rs_data, h, p, q, g, y):
    n = len(rs_data)
    ZmodQ = Zmod(q)
    
    M = []
    
    for i in xrange(n):
        M += [[0] * i + [q] + [0] * (n - i + 1)]
    
    t_vec = []
    u_vec = []
    
    for i in xrange(n):
        r, s = rs_data[i]
        T = 1 / ZmodQ(s)
        t = (r * T) % q
        u = (-h * T) % q
        t_vec += [t]
        u_vec += [u]

    sT = 1
    sU = 1

    M += [t_vec + [sT, 0]]
    M += [u_vec + [0, sU]]

    B = MatrixSpace(ZZ, len(M))(M).LLL()

    for i, v in enumerate(B):
      if v[-1] == sT:
        x = -v[-2] / sU
        return x % q


def findPolynomial(T, M, y_chunk, t=3):
    vu = len(bin(M)[2:])
    av = vu - T
    bv = T
    
    V = []
    for i in range(len(y_chunk)-t):
        Vi = []
        for j in range(t):
            Vi.append(y_chunk[i+j+1]-y_chunk[i+j])
        Vi = vector(ZZ, Vi)
        V.append(Vi)
    NUM_VECTORS = len(V)
    
    K = 1
    KV = [K*Vi for Vi in V]
    lattice = Matrix(ZZ, KV)
    assert lattice.ncols() == t
    
    II = matrix.identity(NUM_VECTORS)
    lattice = lattice.augment(II)
    
    lattice_red = lattice.LLL()
    lambdas = lattice_red[0][t:]
    
    x = PolynomialRing((Integers(M)), 'x').gen()
    poly = 0
    for i in range(len(lambdas)):
        poly += lambdas[i] * x^i
    return lambdas


def recover_present(shift, past, outputs):
    M = past
    T = shift
    y = outputs

    SIZE_PARAM = 10
    T_PARAM = 3
    VECTOR_LEN = SIZE_PARAM - T_PARAM
    NUM_POLYS = 8

    basis_zero_vector = vector(ZZ, [0]*VECTOR_LEN)

    polys = []
    for i in range(NUM_POLYS):
        y_chunk = y[i:i+SIZE_PARAM]
        poly = findPolynomial(T, M, y_chunk, T_PARAM)
        if poly is not None:
            polys.append(poly)

    polyM = Matrix(ZZ, polys)
    polyM_red = polyM.LLL()

    new_basis = []
    for row in polyM_red:
        if row!=basis_zero_vector:
            new_basis.append(row)

    new_polyM = Matrix(ZZ, new_basis)

    new_polyM_normal = new_polyM.transpose() * new_polyM
    det = new_polyM_normal.determinant()
    det = ZZ(det).nth_root(2, truncate_mode=1)[0]

    nrows = new_polyM.nrows()
    ncols = new_polyM.ncols()

    K = M * 2**(NUM_POLYS+3)
    for i in range(nrows):
        for j in range(ncols):
            if j>=2:
                new_polyM[i,j] *= K

    new_polyM_red = new_polyM.LLL()

    sublattice = new_polyM_red.matrix_from_rows([0,1])

    a1 = sublattice[0,0]
    a2 = sublattice[0,1]
    b1 = sublattice[1,0]
    b2 = sublattice[1,1]

    d,u,v = xgcd(a2,b2)
    coeff = u*a1+v*b1
    return -coeff


def recover_future(shift, past, present, outputs):
    p = past
    a = present

    Y = [y << shift for y in outputs]
    
    L = []
    L.append([p] + [0] * (len(Y) - 1))

    for i in range(len(Y) - 1):
        v = [0] * (len(Y) - 1)
        v[i] = -1
        L.append([a^(i+1)] + v)

    L = matrix(L)
    B = L.LLL()

    W1 = B * vector(Y)
    W2 = vector([ round(RR(w) / p) * p - w for w in W1 ])

    Z = list(B.solve_right(W2))
    return Y[-1] + Z[-1] 


def recover_computers(constant, strength, questions, answers):
    K = constant ^ 10

    M = matrix.identity(strength + 1)

    for question, answer in zip(questions, answers):
        k = [K * question^(strength-i-1) for i in range(strength)] + [-K * answer]
        M = M.augment(vector(k))

    B = M.LLL()

    return list(B[0])[:strength]


# 
# OTHER
#


def forge_sign(h, p, q, g, y, x):
    k = 1337
    r = int(pow(g, k, p)) % q
    s = (inverse_mod(k, q) * (h + x * r)) % q
    return r, s


def crack_oracle(past, outputs):
    check_size = 2
    outputs, check = outputs[:-check_size], outputs[-check_size:]
    shift = len(bin(past)[2:]) // 8
    present = recover_present(shift, past, outputs) % past
    future = recover_future(shift, past, present, outputs) % past
    result = [(((present^(i+1)) * future) % past) >> shift for i in range(check_size)]
    if result == check:
        return present % past, (present^check_size * future) % past


def get_questions(past, present, future, count):
    shift = len(bin(past)[2:]) // 8
    return [(((present^(i+1)) * future) % past) >> shift for i in range(count)]


def calculate_answer(question, computers):
    answer = 0
    length = len(computers)
    for i, computer in enumerate(computers):
        answer += computer * (question ** (length - i - 1))
    return answer


#
# MAIN
#


def attack_person(p, q, g, y, io, tries):
    for i in range(tries):
        signs_count = 60
        signs = collect_signatures(io, NAME, signs_count)
        print('got signs')
        x = recover_x(signs, NAME_HASH, p, q, g, y)
        if x:
            print('got x')
            break
        print('failed to recover x')
    else:
        return False
    r, s = forge_sign(HACKER_HASH, p, q, g, y, x)
    print('got r, s')
    change_name(io, HACKER, (r, s))
    print('name changed')
    return True


def attack_oracle(p, io):
    outputs_count = 50
    while True:
        outputs = collect_oracle(io, outputs_count)
        print('got outputs')
        params = crack_oracle(p, outputs)
        if not params:
            print('failed to crack oracle')
            continue
        print('got present, future')
        present, future = params
        break
    questions_count = 3
    questions = get_questions(p, present, future, questions_count)
    print('got questions')
    return questions


def attack_architect(p, questions, io):
    answers_count = 2
    answers = get_architect_answers(io, answers_count)
    print('got answers')
    strength = 10
    computers = recover_computers(p, strength, questions, answers)
    print('got computers')
    answer = calculate_answer(questions[-1], computers)
    print('got answer')
    return answer


def main(address):
    while True:
        sock = socket(AF_INET, SOCK_STREAM)
        sock.settimeout(3)
        sock.connect(address)
        io = sock.makefile('rwb')

        p, q, g, y = numbers(io.readline())
        wakeup(io, NAME)
        print('woke up')
        
        tries = 5
        if attack_person(p, q, g, y, io, tries):
            break

        print('failed to crack person, trying again...')
        sock.close()

    questions = attack_oracle(sum([p, q, g, y]), io)
    answer = attack_architect(p, questions, io)
    
    flag = read_flag(io, answer)
    print('got flag')
    print(flag.strip())
    sock.close()


if __name__ == '__main__':
    ip = sys.argv[1] if len(sys.argv) > 1 else '0.0.0.0'
    main((ip, 40518))
