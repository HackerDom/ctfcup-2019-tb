#!/usr/bin/env python3

import re
import json
import socket

from hashlib import sha512
from collections import OrderedDict

from gmpy2 import invert
from fastecdsa.curve import P521
from fastecdsa.point import Point
from Crypto.Util.number import long_to_bytes, bytes_to_long

from mod_sqrt import modular_sqrt


class Cipher(object):
    def __init__(self, key, curve):
        self._key = bytes_to_long(key)
        self._P, self._Q = self._get_points(curve)

    def crypt(self, text):
        block = self._generate_block(len(text))
        return self._xor(text, block)

    def _get_points(self, curve):
        P = curve.G
        Q = 31337 * P
        return P, Q

    def _generate_block(self, size):
        data = b''
        for number in self._expand_key():
            data += long_to_bytes(number)
            if len(data) >= size:
                break
        return data[:size]

    def _expand_key(self):
        while True:
            self._key = (self._key * self._P).x
            yield (self._key * self._Q).x

    def _xor(self, block1, block2):
        return bytes(x^y for x, y in zip(block1, block2))


def xor(block1, block2):
    return bytes(x^y for x, y in zip(block1, block2))


def recover_seed(value, next_value, curve, backdoor):
    inverse = int(invert(backdoor, curve.q))
    x_higher = bytes_to_long(value)
    for lower in range(1 << 9):
        x = (x_higher << 8) + lower
        y_quad = curve.evaluate(x)
        y = modular_sqrt(y_quad, curve.p)
        if not y:
            continue
        if curve.is_point_on_curve((x, y)):
            point = Point(x, y, curve)
            seed = (inverse * point).x
            key = (backdoor * curve.G * seed).x
            if long_to_bytes(key).startswith(next_value):
                return long_to_bytes(seed)


def recvline(sock):
    data = b''
    while len(data) == 0 or data[-1] != ord('\n'):
        data += sock.recv(1)
    print(data[:-1].decode())
    return data[:-1]


def extract_hash(line):
    return re.search(rb'\w{128}', line).group(0).decode()


def get_sign(sock):
    recvline(sock)
    sign = extract_hash(recvline(sock))
    recvline(sock)
    return sign


def try_option(sock, option):
    sock.send((option + '\n').encode())
    unique = extract_hash(recvline(sock))
    recvline(sock)
    result = b'Good' in recvline(sock)
    recvline(sock)
    return result, unique


def main(address):
    curve, backdoor = P521, 31337
    options = ['heads', 'tails']
    uniques = [
        sha512(b'{"heads": "you win", "tails": "you lose"}').digest(),
        sha512(b'{"tails": "you win", "heads": "you lose"}').digest()
    ]
    objects = [
        OrderedDict([('heads', 'you win'), ('tails', 'you lose')]),
        OrderedDict([('tails', 'you win'), ('heads', 'you lose')])
    ]
    while True:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(3)
            sock.connect(address)
            values = []
            for i in range(2):
                get_sign(sock)
                result, unique = try_option(sock, options[0])
                if not result:
                    break
                values.append(xor(uniques[0], bytes.fromhex(unique)))
            if len(values) != 2:
                print('wrong guess')
                continue
            seed = recover_seed(values[0], values[1], curve, backdoor)
            cipher = Cipher(seed, curve)
            for i in range(2, 50):
                sign = get_sign(sock)
                value = cipher.crypt(b'\x00' * 64)
                for opt, uniq, obj in zip(options, uniques, objects):
                    obj = obj.copy()
                    obj['unique'] = xor(uniq, value).hex()
                    if sha512(json.dumps(obj).encode()).hexdigest() == sign:
                        break
                result, unique = try_option(sock, opt)
                if result:
                    print('%d passed!' % i)
            for i in range(3):
                recvline(sock)
            return


if __name__ == '__main__':
    ip = sys.argv[1] if len(sys.argv) > 1 else '0.0.0.0'
    main((ip, 44147))
