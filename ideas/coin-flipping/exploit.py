#!/usr/bin/env python3

import re
import json
import socket

from hashlib import sha512
from collections import OrderedDict

from gmpy2 import invert
from fastecdsa.curve import P521
from fastecdsa.point import Point
from Crypto.Util.number import long_to_bytes, bytes_to_long

from server import Cipher
from mod_sqrt import modular_sqrt


def xor(block1, block2):
    return bytes(x^y for x, y in zip(block1, block2))


def recover_seed(value, next_value, curve, backdoor):
    inverse = int(invert(backdoor, curve.q))
    x_higher = bytes_to_long(value)
    for lower in range(1 << 9):
        x = (x_higher << 8) + lower
        y_quad = curve.evaluate(x)
        y = modular_sqrt(y_quad, curve.p)
        if not y:
            continue
        if curve.is_point_on_curve((x, y)):
            point = Point(x, y, curve)
            seed = (inverse * point).x
            key = (backdoor * curve.G * seed).x
            if long_to_bytes(key).startswith(next_value):
                return long_to_bytes(seed)


def recvline(sock):
    data = b''
    while len(data) == 0 or data[-1] != ord('\n'):
        data += sock.recv(1)
    print(data[:-1].decode())
    return data[:-1]


def extract_hash(line):
    return re.search(rb'\w{128}', line).group(0).decode()


def get_sign(sock):
    recvline(sock)
    sign = extract_hash(recvline(sock))
    recvline(sock)
    return sign


def try_option(sock, option):
    sock.send((option + '\n').encode())
    unique = extract_hash(recvline(sock))
    recvline(sock)
    result = b'Good' in recvline(sock)
    recvline(sock)
    return result, unique


def main(address):
    curve, backdoor = P521, 31337
    options = ['heads', 'tails']
    uniques = [
        sha512(b'{"heads": "you win", "tails": "you lose"}').digest(),
        sha512(b'{"tails": "you win", "heads": "you lose"}').digest()
    ]
    objects = [
        OrderedDict([('heads', 'you win'), ('tails', 'you lose')]),
        OrderedDict([('tails', 'you win'), ('heads', 'you lose')])
    ]
    while True:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(3)
            sock.connect(address)
            values = []
            for i in range(2):
                get_sign(sock)
                result, unique = try_option(sock, options[0])
                if not result:
                    break
                values.append(xor(uniques[0], bytes.fromhex(unique)))
            if len(values) != 2:
                print('wrong guess')
                continue
            seed = recover_seed(values[0], values[1], curve, backdoor)
            cipher = Cipher(seed, curve)
            for i in range(2, 50):
                sign = get_sign(sock)
                value = cipher.crypt(b'\x00' * 64)
                for opt, uniq, obj in zip(options, uniques, objects):
                    obj = obj.copy()
                    obj['unique'] = xor(uniq, value).hex()
                    if sha512(json.dumps(obj).encode()).hexdigest() == sign:
                        break
                result, unique = try_option(sock, opt)
                if result:
                    print('%d passed!' % i)
            for i in range(3):
                recvline(sock)
            return


if __name__ == '__main__':
    main(('0.0.0.0', 31337))
